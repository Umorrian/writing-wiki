// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: query.sql

package gen

import (
	"context"
)

const deleteArticle = `-- name: DeleteArticle :exec
DELETE FROM articles
WHERE id = ?
`

func (q *Queries) DeleteArticle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteArticle, id)
	return err
}

const insertArticle = `-- name: InsertArticle :one
INSERT INTO articles (
title, created_at
) VALUES (?, DATETIME())
RETURNING id, title, created_at, updated_at
`

func (q *Queries) InsertArticle(ctx context.Context, title string) (Article, error) {
	row := q.db.QueryRowContext(ctx, insertArticle, title)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertArticleTextVersion = `-- name: InsertArticleTextVersion :one
INSERT INTO article_texts (
article_id, content, version, created_at
) VALUES (
?,
?,
(SELECT MAX(version)+1
 FROM article_texts as subat
 WHERE subat.id=?
 GROUP BY subat.version),
DATETIME())
RETURNING id, article_id, content, version, created_at, updated_at
`

type InsertArticleTextVersionParams struct {
	ArticleID int64
	Content   string
}

func (q *Queries) InsertArticleTextVersion(ctx context.Context, arg InsertArticleTextVersionParams) (ArticleText, error) {
	row := q.db.QueryRowContext(ctx, insertArticleTextVersion, arg.ArticleID, arg.Content)
	var i ArticleText
	err := row.Scan(
		&i.ID,
		&i.ArticleID,
		&i.Content,
		&i.Version,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const selectAllArticles = `-- name: SelectAllArticles :many
SELECT id, title, created_at, updated_at FROM articles
`

func (q *Queries) SelectAllArticles(ctx context.Context) ([]Article, error) {
	rows, err := q.db.QueryContext(ctx, selectAllArticles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectArticleByNameWithCurrentContent = `-- name: SelectArticleByNameWithCurrentContent :one
SELECT a.id, a.title, a.created_at, a.updated_at, at.id, at.article_id, at.content, at.version, at.created_at, at.updated_at FROM articles as a
JOIN article_texts at on a.id = at.article_id
WHERE a.title = ?
ORDER BY at.version DESC
LIMIT 1
`

type SelectArticleByNameWithCurrentContentRow struct {
	Article     Article
	ArticleText ArticleText
}

func (q *Queries) SelectArticleByNameWithCurrentContent(ctx context.Context, title string) (SelectArticleByNameWithCurrentContentRow, error) {
	row := q.db.QueryRowContext(ctx, selectArticleByNameWithCurrentContent, title)
	var i SelectArticleByNameWithCurrentContentRow
	err := row.Scan(
		&i.Article.ID,
		&i.Article.Title,
		&i.Article.CreatedAt,
		&i.Article.UpdatedAt,
		&i.ArticleText.ID,
		&i.ArticleText.ArticleID,
		&i.ArticleText.Content,
		&i.ArticleText.Version,
		&i.ArticleText.CreatedAt,
		&i.ArticleText.UpdatedAt,
	)
	return i, err
}

const selectArticleTextVersionsByArticleId = `-- name: SelectArticleTextVersionsByArticleId :many
SELECT id, article_id, content, version, created_at, updated_at FROM article_texts
where article_id = ?
`

func (q *Queries) SelectArticleTextVersionsByArticleId(ctx context.Context, articleID int64) ([]ArticleText, error) {
	rows, err := q.db.QueryContext(ctx, selectArticleTextVersionsByArticleId, articleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ArticleText
	for rows.Next() {
		var i ArticleText
		if err := rows.Scan(
			&i.ID,
			&i.ArticleID,
			&i.Content,
			&i.Version,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectArticleWithCurrentContent = `-- name: SelectArticleWithCurrentContent :one
SELECT a.id, a.title, a.created_at, a.updated_at, at.id, at.article_id, at.content, at.version, at.created_at, at.updated_at FROM articles as a
JOIN article_texts at on a.id = at.article_id
WHERE a.id = ?
ORDER BY at.version DESC
LIMIT 1
`

type SelectArticleWithCurrentContentRow struct {
	Article     Article
	ArticleText ArticleText
}

func (q *Queries) SelectArticleWithCurrentContent(ctx context.Context, id int64) (SelectArticleWithCurrentContentRow, error) {
	row := q.db.QueryRowContext(ctx, selectArticleWithCurrentContent, id)
	var i SelectArticleWithCurrentContentRow
	err := row.Scan(
		&i.Article.ID,
		&i.Article.Title,
		&i.Article.CreatedAt,
		&i.Article.UpdatedAt,
		&i.ArticleText.ID,
		&i.ArticleText.ArticleID,
		&i.ArticleText.Content,
		&i.ArticleText.Version,
		&i.ArticleText.CreatedAt,
		&i.ArticleText.UpdatedAt,
	)
	return i, err
}

const updateArticle = `-- name: UpdateArticle :exec
UPDATE articles
set title = ?,
    updated_at = DATETIME()
WHERE id = ?
`

type UpdateArticleParams struct {
	Title string
	ID    int64
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) error {
	_, err := q.db.ExecContext(ctx, updateArticle, arg.Title, arg.ID)
	return err
}
